{"version":3,"file":"TelemetryClient.js","sourceRoot":"","sources":["../../Library/TelemetryClient.ts"],"names":[],"mappings":"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","sourcesContent":["import url = require(\"url\");\nimport os = require(\"os\");\n\nimport Config = require(\"./Config\");\nimport AuthorizationHandler = require(\"./AuthorizationHandler\");\nimport Context = require(\"./Context\");\nimport Contracts = require(\"../Declarations/Contracts\");\nimport Channel = require(\"./Channel\");\nimport TelemetryProcessors = require(\"../TelemetryProcessors\");\nimport { CorrelationContextManager } from \"../AutoCollection/CorrelationContextManager\";\nimport Statsbeat = require(\"../AutoCollection/Statsbeat\");\nimport Sender = require(\"./Sender\");\nimport Util = require(\"./Util\");\nimport Logging = require(\"./Logging\");\nimport FlushOptions = require(\"./FlushOptions\");\nimport EnvelopeFactory = require(\"./EnvelopeFactory\");\nimport QuickPulseStateManager = require(\"./QuickPulseStateManager\");\nimport { Tags } from \"../Declarations/Contracts\";\n\n/**\n * Application Insights telemetry client provides interface to track telemetry items, register telemetry initializers and\n * and manually trigger immediate sending (flushing)\n */\nclass TelemetryClient {\n    private static TAG = \"TelemetryClient\";\n    private _telemetryProcessors: { (envelope: Contracts.EnvelopeTelemetry, contextObjects: { [name: string]: any; }): boolean; }[] = [];\n    private _enableAzureProperties: boolean = false;\n    private _statsbeat: Statsbeat;\n\n    public config: Config;\n    public context: Context;\n    public commonProperties: { [key: string]: string; };\n    public channel: Channel;\n    public quickPulseClient: QuickPulseStateManager;\n    public authorizationHandler: AuthorizationHandler;\n\n    /**\n     * Constructs a new client of the client\n     * @param setupString the Connection String or Instrumentation Key to use (read from environment variable if not specified)\n     */\n    constructor(setupString?: string) {\n        var config = new Config(setupString);\n        this.config = config;\n        if (!this.config.instrumentationKey || this.config.instrumentationKey == \"\") {\n            throw new Error(\"Instrumentation key not found, please provide a connection string before starting Application Insights SDK.\");\n        }\n        this.context = new Context();\n        this.commonProperties = {};\n        this.authorizationHandler = null;\n        if (!this.config.disableStatsbeat) {\n            this._statsbeat = new Statsbeat(this.config, this.context);\n            this._statsbeat.enable(true);\n        }\n        var sender = new Sender(this.config, this.getAuthorizationHandler, null, null, this._statsbeat);\n        this.channel = new Channel(() => config.disableAppInsights, () => config.maxBatchSize, () => config.maxBatchIntervalMs, sender);\n    }\n\n    /**\n     * Log information about availability of an application\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackAvailability(telemetry: Contracts.AvailabilityTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Availability);\n    }\n\n    /**\n     * Log a page view\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackPageView(telemetry: Contracts.PageViewTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.PageView);\n    }\n\n    /**\n     * Log a trace message\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackTrace(telemetry: Contracts.TraceTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Trace);\n    }\n\n    /**\n     * Log a numeric value that is not associated with a specific event. Typically used to send regular reports of performance indicators.\n     * To send a single measurement, use just the first two parameters. If you take measurements very frequently, you can reduce the\n     * telemetry bandwidth by aggregating multiple measurements and sending the resulting average at intervals.\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackMetric(telemetry: Contracts.MetricTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Metric);\n    }\n\n    /**\n     * Log an exception\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackException(telemetry: Contracts.ExceptionTelemetry): void {\n        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {\n            telemetry.exception = new Error(telemetry.exception.toString());\n        }\n        this.track(telemetry, Contracts.TelemetryType.Exception);\n    }\n\n    /**\n     * Log a user action or other occurrence.\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackEvent(telemetry: Contracts.EventTelemetry): void {\n        this.track(telemetry, Contracts.TelemetryType.Event);\n    }\n\n    /**\n     * Log a request. Note that the default client will attempt to collect HTTP requests automatically so only use this for requests\n     * that aren't automatically captured or if you've disabled automatic request collection.\n     *\n     * @param telemetry      Object encapsulating tracking options\n     */\n    public trackRequest(telemetry: Contracts.RequestTelemetry & Contracts.Identified): void {\n        this.track(telemetry, Contracts.TelemetryType.Request);\n    }\n\n    /**\n     * Log a dependency. Note that the default client will attempt to collect dependencies automatically so only use this for dependencies\n     * that aren't automatically captured or if you've disabled automatic dependency collection.\n     *\n     * @param telemetry      Object encapsulating tracking option\n     * */\n    public trackDependency(telemetry: Contracts.DependencyTelemetry & Contracts.Identified) {\n\n        if (telemetry && !telemetry.target && telemetry.data) {\n            // url.parse().host returns null for non-urls,\n            // making this essentially a no-op in those cases\n            // If this logic is moved, update jsdoc in DependencyTelemetry.target\n            // url.parse() is deprecated, update to use WHATWG URL API instead\n            try {\n                telemetry.target = new url.URL(telemetry.data).host;\n            } catch (error) {\n                // set target as null to be compliant with previous behavior\n                telemetry.target = null;\n                Logging.warn(TelemetryClient.TAG, \"The URL object is failed to create.\", error);\n            }\n        }\n        this.track(telemetry, Contracts.TelemetryType.Dependency);\n    }\n\n    /**\n     * Immediately send all queued telemetry.\n     * @param options Flush options, including indicator whether app is crashing and callback\n     */\n    public flush(options?: FlushOptions) {\n        this.channel.triggerSend(\n            options ? !!options.isAppCrashing : false,\n            options ? options.callback : undefined);\n    }\n\n    /**\n     * Generic track method for all telemetry types\n     * @param data the telemetry to send\n     * @param telemetryType specify the type of telemetry you are tracking from the list of Contracts.DataTypes\n     */\n    public track(telemetry: Contracts.Telemetry, telemetryType: Contracts.TelemetryType) {\n        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {\n            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);\n\n            // Set time on the envelope if it was set on the telemetry item\n            if (telemetry.time) {\n                envelope.time = telemetry.time.toISOString();\n            }\n            if (this._enableAzureProperties) {\n                TelemetryProcessors.azureRoleEnvironmentTelemetryProcessor(envelope, this.context);\n            }\n            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);\n\n            // Ideally we would have a central place for \"internal\" telemetry processors and users can configure which ones are in use.\n            // This will do for now. Otherwise clearTelemetryProcessors() would be problematic.\n            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager.getCurrentContext() });\n            TelemetryProcessors.preAggregatedMetricsTelemetryProcessor(envelope, this.context);\n            if (accepted) {\n                TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);\n                this.channel.send(envelope);\n            }\n        }\n        else {\n            Logging.warn(TelemetryClient.TAG, \"track() requires telemetry object and telemetryType to be specified.\")\n        }\n    }\n\n    /**\n     * Automatically populate telemetry properties like RoleName when running in Azure\n     *\n      * @param value if true properties will be populated\n     */\n    public setAutoPopulateAzureProperties(value: boolean) {\n        this._enableAzureProperties = value;\n    }\n\n    /**\n     * Get Authorization handler\n     */\n    public getAuthorizationHandler(config: Config): AuthorizationHandler {\n        if (config && config.aadTokenCredential) {\n            if (!this.authorizationHandler) {\n                Logging.info(TelemetryClient.TAG, \"Adding authorization handler\");\n                this.authorizationHandler = new AuthorizationHandler(config.aadTokenCredential)\n            }\n            return this.authorizationHandler;\n        }\n        return null;\n    }\n\n    /**\n     * Adds telemetry processor to the collection. Telemetry processors will be called one by one\n     * before telemetry item is pushed for sending and in the order they were added.\n     *\n     * @param telemetryProcessor function, takes Envelope, and optional context object and returns boolean\n     */\n    public addTelemetryProcessor(telemetryProcessor: (envelope: Contracts.EnvelopeTelemetry, contextObjects?: { [name: string]: any; }) => boolean) {\n        this._telemetryProcessors.push(telemetryProcessor);\n    }\n\n    /*\n     * Removes all telemetry processors\n     */\n    public clearTelemetryProcessors() {\n        this._telemetryProcessors = [];\n    }\n\n    private runTelemetryProcessors(envelope: Contracts.EnvelopeTelemetry, contextObjects: { [name: string]: any; }): boolean {\n        var accepted = true;\n        var telemetryProcessorsCount = this._telemetryProcessors.length;\n\n        if (telemetryProcessorsCount === 0) {\n            return accepted;\n        }\n\n        contextObjects = contextObjects || {};\n        contextObjects[\"correlationContext\"] = CorrelationContextManager.getCurrentContext();\n\n        for (var i = 0; i < telemetryProcessorsCount; ++i) {\n            try {\n                var processor = this._telemetryProcessors[i];\n                if (processor) {\n                    if (processor.apply(null, [envelope, contextObjects]) === false) {\n                        accepted = false;\n                        break;\n                    }\n                }\n\n            } catch (error) {\n                accepted = true;\n                Logging.warn(TelemetryClient.TAG, \"One of telemetry processors failed, telemetry item will be sent.\", error, envelope);\n            }\n        }\n\n        // Sanitize tags and properties after running telemetry processors\n        if (accepted) {\n            if (envelope && envelope.tags) {\n                envelope.tags = Util.validateStringMap(envelope.tags) as Tags & Tags[];\n            }\n            if (envelope && envelope.data && envelope.data.baseData && envelope.data.baseData.properties) {\n                envelope.data.baseData.properties = Util.validateStringMap(envelope.data.baseData.properties);\n            }\n        }\n\n        return accepted;\n    }\n\n    /*\n     * Get Statsbeat instance\n     */\n    public getStatsbeat() {\n        return this._statsbeat;\n    }\n}\n\nexport = TelemetryClient;\n"]}