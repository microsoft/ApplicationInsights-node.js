{"version":3,"file":"ConnectionStringParser.js","sourceRoot":"","sources":["../../Library/ConnectionStringParser.ts"],"names":[],"mappings":";AACA,qDAAwD;AAExD;IAAA;IA8CA,CAAC;IA1CiB,4BAAK,GAAnB,UAAoB,gBAAyB;QACzC,IAAI,CAAC,gBAAgB,EAAE;YACnB,OAAO,EAAE,CAAC;SACb;QAED,IAAM,OAAO,GAAG,gBAAgB,CAAC,KAAK,CAAC,sBAAsB,CAAC,iBAAiB,CAAC,CAAC;QAEjF,IAAM,MAAM,GAAqB,OAAO,CAAC,MAAM,CAAC,UAAC,MAAwB,EAAE,EAAU;YACjF,IAAM,OAAO,GAAG,EAAE,CAAC,KAAK,CAAC,sBAAsB,CAAC,0BAA0B,CAAC,CAAC;YAE5E,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,EAAE,sCAAsC;gBAC9D,IAAM,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,WAAW,EAAyB,CAAC;gBAC5D,IAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC,GAAG,CAAC,GAAG,KAAe,CAAC;aACjC;YACD,OAAO,MAAM,CAAC;QAClB,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;YAChC,0DAA0D;YAE1D,IAAI,MAAM,CAAC,cAAc,EAAE;gBACvB,uDAAuD;gBACvD,IAAM,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;gBACpE,MAAM,CAAC,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,IAAI,CAAC,UAAU,GAAG,cAAc,GAAG,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;gBACrH,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,IAAI,CAAC,UAAU,GAAG,cAAc,GAAG,OAAO,GAAG,MAAM,CAAC,cAAc,CAAC,CAAC;aAChH;YAED,8BAA8B;YAC9B,MAAM,CAAC,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,IAAI,SAAS,CAAC,uBAAuB,CAAC;YACzF,MAAM,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,IAAI,SAAS,CAAC,4BAA4B,CAAC;SACvF;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAEa,kCAAW,GAAzB,UAA0B,IAAY;QAClC,IAAI,CAAC,IAAI,IAAI,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;QACtC,IAAM,UAAU,GAAG,gEAAgE,CAAC;QACpF,IAAM,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC;QACtC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7B,CAAC;IA5Cc,wCAAiB,GAAG,GAAG,CAAC;IACxB,iDAA0B,GAAG,GAAG,CAAC;IA4CpD,6BAAC;CAAA,AA9CD,IA8CC;AAED,iBAAS,sBAAsB,CAAC","sourcesContent":["import { ConnectionString, ConnectionStringKey } from \"../Declarations/Contracts\";\nimport Constants = require(\"../Declarations/Constants\");\n\nclass ConnectionStringParser {\n    private static _FIELDS_SEPARATOR = \";\";\n    private static _FIELD_KEY_VALUE_SEPARATOR = \"=\";\n\n    public static parse(connectionString?: string): ConnectionString {\n        if (!connectionString) {\n            return {};\n        }\n\n        const kvPairs = connectionString.split(ConnectionStringParser._FIELDS_SEPARATOR);\n\n        const result: ConnectionString = kvPairs.reduce((fields: ConnectionString, kv: string) => {\n            const kvParts = kv.split(ConnectionStringParser._FIELD_KEY_VALUE_SEPARATOR);\n\n            if (kvParts.length === 2) { // only save fields with valid formats\n                const key = kvParts[0].toLowerCase() as ConnectionStringKey;\n                const value = kvParts[1];\n                fields[key] = value as string;\n            }\n            return fields;\n        }, {});\n\n        if (Object.keys(result).length > 0) {\n            // this is a valid connection string, so parse the results\n\n            if (result.endpointsuffix) {\n                // use endpoint suffix where overrides are not provided\n                const locationPrefix = result.location ? result.location + \".\" : \"\";\n                result.ingestionendpoint = result.ingestionendpoint || (\"https://\" + locationPrefix + \"dc.\" + result.endpointsuffix);\n                result.liveendpoint = result.liveendpoint || (\"https://\" + locationPrefix + \"live.\" + result.endpointsuffix);\n            }\n\n            // apply the default endpoints\n            result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT;\n            result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;\n        }\n\n        return result;\n    }\n\n    public static isIkeyValid(iKey: string): boolean {\n        if (!iKey || iKey == \"\") return false;\n        const UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\n        const regexp = new RegExp(UUID_Regex);\n        return regexp.test(iKey);\n    }\n}\n\nexport = ConnectionStringParser;\n"]}