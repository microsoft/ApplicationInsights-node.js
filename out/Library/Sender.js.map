{"version":3,"file":"Sender.js","sourceRoot":"","sources":["../../Library/Sender.ts"],"names":[],"mappings":"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","sourcesContent":["import fs = require(\"fs\");\nimport http = require(\"http\");\nimport os = require(\"os\");\nimport path = require(\"path\");\nimport zlib = require(\"zlib\");\n\nimport AuthorizationHandler = require(\"./AuthorizationHandler\");\nimport Config = require(\"./Config\")\nimport Contracts = require(\"../Declarations/Contracts\");\nimport Constants = require(\"../Declarations/Constants\");\nimport AutoCollectHttpDependencies = require(\"../AutoCollection/HttpDependencies\");\nimport Statsbeat = require(\"../AutoCollection/Statsbeat\");\nimport FileSystemHelper = require(\"./FileSystemHelper\");\nimport Util = require(\"./Util\");\nimport { URL } from \"url\";\nimport Logging = require(\"./Logging\");\nimport { FileAccessControl } from \"./FileAccessControl\";\n\nconst legacyThrottleStatusCode = 439; //  - Too many requests and refresh cache\nconst throttleStatusCode = 402; // Monthly Quota Exceeded (new SDK)\nconst RESPONSE_CODES_INDICATING_REACHED_BREEZE = [200, 206, 402, 408, 429, 439, 500];\n\nclass Sender {\n    private static TAG = \"Sender\";\n    // the amount of time the SDK will wait between resending cached data, this buffer is to avoid any throttling from the service side\n    public static WAIT_BETWEEN_RESEND = 60 * 1000; // 1 minute\n    public static MAX_BYTES_ON_DISK = 50 * 1024 * 1024; // 50 mb\n    public static MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\n    public static CLEANUP_TIMEOUT = 60 * 60 * 1000; // 1 hour\n    public static FILE_RETEMPTION_PERIOD = 7 * 24 * 60 * 60 * 1000; // 7 days\n    public static TEMPDIR_PREFIX: string = \"appInsights-node\";\n    public static HTTP_TIMEOUT: number = 20000; // 20 seconds\n\n    private _config: Config;\n    private _isStatsbeatSender: boolean;\n    private _shutdownStatsbeat: () => void;\n    private _failedToIngestCounter: number;\n    private _statsbeatHasReachedIngestionAtLeastOnce: boolean;\n    private _statsbeat: Statsbeat;\n    private _onSuccess: (response: string) => void;\n    private _onError: (error: Error) => void;\n    private _getAuthorizationHandler: (config: Config) => AuthorizationHandler;\n    private _enableDiskRetryMode: boolean;\n    private _numConsecutiveFailures: number;\n    private _numConsecutiveRedirects: number;\n    private _resendTimer: NodeJS.Timer | null;\n    private _fileCleanupTimer: NodeJS.Timer;\n    private _redirectedHost: string = null;\n    private _tempDir: string;\n    private _requestTimedOut: boolean;\n    protected _resendInterval: number;\n    protected _maxBytesOnDisk: number;\n\n    constructor(config: Config, getAuthorizationHandler?: (config: Config) => AuthorizationHandler, onSuccess?: (response: string) => void, onError?: (error: Error) => void, statsbeat?: Statsbeat, isStatsbeatSender?: boolean, shutdownStatsbeat?: () => void) {\n        this._config = config;\n        this._onSuccess = onSuccess;\n        this._onError = onError;\n        this._statsbeat = statsbeat;\n        this._enableDiskRetryMode = false;\n        this._resendInterval = Sender.WAIT_BETWEEN_RESEND;\n        this._maxBytesOnDisk = Sender.MAX_BYTES_ON_DISK;\n        this._numConsecutiveFailures = 0;\n        this._numConsecutiveRedirects = 0;\n        this._resendTimer = null;\n        this._getAuthorizationHandler = getAuthorizationHandler;\n        this._fileCleanupTimer = null;\n        // tmpdir is /tmp for *nix and USERDIR/AppData/Local/Temp for Windows\n        this._tempDir = path.join(os.tmpdir(), Sender.TEMPDIR_PREFIX + this._config.instrumentationKey);\n        this._isStatsbeatSender = isStatsbeatSender || false;\n        this._shutdownStatsbeat = shutdownStatsbeat;\n        this._failedToIngestCounter = 0;\n        this._statsbeatHasReachedIngestionAtLeastOnce = false;\n    }\n\n    /**\n    * Enable or disable offline mode\n    */\n    public setDiskRetryMode(value: boolean, resendInterval?: number, maxBytesOnDisk?: number) {\n        if (value) {\n            FileAccessControl.checkFileProtection(); // Only check file protection when disk retry is enabled\n        }\n        this._enableDiskRetryMode = FileAccessControl.OS_PROVIDES_FILE_PROTECTION && value;\n        if (typeof resendInterval === \"number\" && resendInterval >= 0) {\n            this._resendInterval = Math.floor(resendInterval);\n        }\n        if (typeof maxBytesOnDisk === \"number\" && maxBytesOnDisk >= 0) {\n            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);\n        }\n\n        if (value && !FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {\n            this._enableDiskRetryMode = false;\n            this._logWarn(\"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\")\n        }\n        if (this._enableDiskRetryMode) {\n            if (this._statsbeat) {\n                this._statsbeat.addFeature(Constants.StatsbeatFeature.DISK_RETRY);\n            }\n            // Starts file cleanup task\n            if (!this._fileCleanupTimer) {\n                this._fileCleanupTimer = setTimeout(() => { this._fileCleanupTask(); }, Sender.CLEANUP_TIMEOUT);\n                this._fileCleanupTimer.unref();\n            }\n        }\n        else {\n            if (this._statsbeat) {\n                this._statsbeat.removeFeature(Constants.StatsbeatFeature.DISK_RETRY);\n            }\n            if (this._fileCleanupTimer) {\n                clearTimeout(this._fileCleanupTimer);\n            }\n        }\n    }\n\n    public async send(envelopes: Contracts.EnvelopeTelemetry[], callback?: (v: string) => void) {\n        if (envelopes) {\n            var endpointUrl = this._redirectedHost || this._config.endpointUrl;\n\n            var endpointHost = new URL(endpointUrl).hostname;\n\n            // todo: investigate specifying an agent here: https://nodejs.org/api/http.html#http_class_http_agent\n            var options = {\n                method: \"POST\",\n                withCredentials: false,\n                headers: <{ [key: string]: string }>{\n                    \"Content-Type\": \"application/x-json-stream\"\n                }\n            };\n\n            let authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null;\n            if (authHandler) {\n                if (this._statsbeat) {\n                    this._statsbeat.addFeature(Constants.StatsbeatFeature.AAD_HANDLING);\n                }\n                try {\n                    // Add bearer token\n                    await authHandler.addAuthorizationHeader(options);\n                }\n                catch (authError) {\n                    let errorMsg = \"Failed to get AAD bearer token for the Application.\";\n                    if (this._enableDiskRetryMode) {\n                        errorMsg += \"This batch of telemetry items will be retried. \";\n                        this._storeToDisk(envelopes);\n                    }\n                    errorMsg += \"Error:\" + authError.toString();\n                    this._logWarn(errorMsg);\n\n                    if (typeof callback === \"function\") {\n                        callback(errorMsg);\n                    }\n                    return; // If AAD auth fails do not send to Breeze\n                }\n            }\n\n            let batch: string = \"\";\n            envelopes.forEach(envelope => {\n                var payload: string = Util.stringify(envelope);\n                if (typeof payload !== \"string\") {\n                    return;\n                }\n                batch += payload + \"\\n\";\n            });\n            // Remove last \\n\n            if (batch.length > 0) {\n                batch = batch.substring(0, batch.length - 1);\n            }\n\n            let payload: Buffer = Buffer.from ? Buffer.from(batch) : new Buffer(batch);\n\n            zlib.gzip(payload, (err, buffer) => {\n                var dataToSend = buffer;\n                if (err) {\n                    this._logWarn(Util.dumpObj(err));\n                    dataToSend = payload; // something went wrong so send without gzip\n                    options.headers[\"Content-Length\"] = payload.length.toString();\n                } else {\n                    options.headers[\"Content-Encoding\"] = \"gzip\";\n                    options.headers[\"Content-Length\"] = buffer.length.toString();\n                }\n\n                this._logInfo(Util.dumpObj(options));\n\n                // Ensure this request is not captured by auto-collection.\n                (<any>options)[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;\n\n                let startTime = +new Date();\n\n                var requestCallback = (res: http.ClientResponse) => {\n                    res.setEncoding(\"utf-8\");\n\n                    //returns empty if the data is accepted\n                    var responseString = \"\";\n                    res.on(\"data\", (data: string) => {\n                        responseString += data;\n                    });\n\n                    res.on(\"end\", () => {\n                        let endTime = +new Date();\n                        let duration = endTime - startTime;\n                        this._numConsecutiveFailures = 0;\n                        // Handling of Statsbeat instance sending data, should turn it off if is not able to reach ingestion endpoint\n                        if (this._isStatsbeatSender && !this._statsbeatHasReachedIngestionAtLeastOnce) {\n                            if (RESPONSE_CODES_INDICATING_REACHED_BREEZE.includes(res.statusCode)) {\n                                this._statsbeatHasReachedIngestionAtLeastOnce = true;\n                            }\n                            else {\n                                this._statsbeatFailedToIngest();\n                            }\n                        }\n                        if (this._statsbeat) {\n                            if (res.statusCode == throttleStatusCode || res.statusCode == legacyThrottleStatusCode) { // Throttle\n                                this._statsbeat.countThrottle(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);\n                            }\n                            else {\n                                this._statsbeat.countRequest(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, duration, res.statusCode === 200, res.statusCode);\n                            }\n                        }\n                        if (this._enableDiskRetryMode) {\n                            // try to send any cached events if the user is back online\n                            if (res.statusCode === 200) {\n                                if (!this._resendTimer) {\n                                    this._resendTimer = setTimeout(() => {\n                                        this._resendTimer = null;\n                                        this._sendFirstFileOnDisk()\n                                    }, this._resendInterval);\n                                    this._resendTimer.unref();\n                                }\n                            } else if (this._isRetriable(res.statusCode)) {\n                                try {\n                                    if (this._statsbeat) {\n                                        this._statsbeat.countRetry(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);\n                                    }\n                                    const breezeResponse = JSON.parse(responseString) as Contracts.BreezeResponse;\n                                    let filteredEnvelopes: Contracts.EnvelopeTelemetry[] = [];\n                                    if (breezeResponse.errors) {\n                                        breezeResponse.errors.forEach(error => {\n                                            // Only retry errors if 429, 500 or 503 response codes\n                                            if (error.statusCode == 429 || error.statusCode == 500 || error.statusCode == 503) {\n                                                filteredEnvelopes.push(envelopes[error.index]);\n                                            }\n                                        });\n                                        if (filteredEnvelopes.length > 0) {\n                                            this._storeToDisk(filteredEnvelopes);\n                                        }\n                                    }\n\n                                }\n                                catch (ex) {\n                                    this._storeToDisk(envelopes); // Retriable status code with not valid Breeze response\n                                }\n                            }\n                        }\n                        // Redirect handling\n                        if (res.statusCode === 307 || // Temporary Redirect\n                            res.statusCode === 308) { // Permanent Redirect\n                            this._numConsecutiveRedirects++;\n                            // To prevent circular redirects\n                            if (this._numConsecutiveRedirects < 10) {\n                                // Try to get redirect header\n                                const locationHeader = res.headers[\"location\"] ? res.headers[\"location\"].toString() : null;\n                                if (locationHeader) {\n                                    this._redirectedHost = locationHeader;\n                                    // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically\n                                    this.send(envelopes, callback);\n                                }\n                            }\n                            else {\n                                const circularRedirectError: Error = { name: \"Circular Redirect\", message: \"Error sending telemetry because of circular redirects.\" }\n                                if (this._statsbeat) {\n                                    this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, circularRedirectError);\n                                }\n                                if (typeof callback === \"function\") {\n                                    callback(\"Error sending telemetry because of circular redirects.\");\n                                }\n                            }\n\n                        }\n                        else {\n                            this._numConsecutiveRedirects = 0;\n                            if (typeof callback === \"function\") {\n                                callback(responseString);\n                            }\n                            this._logInfo(responseString);\n                            if (typeof this._onSuccess === \"function\") {\n                                this._onSuccess(responseString);\n                            }\n                        }\n                    });\n                };\n\n                var req = Util.makeRequest(this._config, endpointUrl, options, requestCallback);\n\n                // Needed as of Node.js v13 default timeouts on HTTP requests are no longer default\n                // Timeout should trigger the request on error function to run\n                req.setTimeout(Sender.HTTP_TIMEOUT, () => {\n                    this._requestTimedOut = true;\n                    req.abort();\n                });\n\n                req.on(\"error\", (error: Error) => {\n                    if (this._isStatsbeatSender && !this._statsbeatHasReachedIngestionAtLeastOnce) {\n                        this._statsbeatFailedToIngest();\n                    }\n                    // todo: handle error codes better (group to recoverable/non-recoverable and persist)\n                    this._numConsecutiveFailures++;\n                    if (this._statsbeat) {\n                        this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, error);\n                    }\n\n                    // Only use warn level if retries are disabled or we've had some number of consecutive failures sending data\n                    // This is because warn level is printed in the console by default, and we don't want to be noisy for transient and self-recovering errors\n                    // Continue informing on each failure if verbose logging is being used\n                    if (!this._enableDiskRetryMode || this._numConsecutiveFailures > 0 && this._numConsecutiveFailures % Sender.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {\n                        let notice = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\n                        if (this._enableDiskRetryMode) {\n                            notice = `Ingestion endpoint could not be reached ${this._numConsecutiveFailures} consecutive times. There may be resulting telemetry loss. Most recent error:`;\n                        }\n                        this._logWarn(notice, Util.dumpObj(error));\n                    } else {\n                        let notice = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\";\n                        this._logInfo(notice, Util.dumpObj(error));\n                    }\n                    this._onErrorHelper(error);\n\n                    if (typeof callback === \"function\") {\n                        if (error) {\n                            // If the error type is a timeout we want to provide more meaningful output\n                            if (this._requestTimedOut) {\n                                error.name = \"telemetry timeout\";\n                                error.message = \"telemetry request timed out\";\n                            }\n                            callback(Util.dumpObj(error));\n                        }\n                        else {\n                            callback(\"Error sending telemetry\");\n                        }\n                    }\n\n                    if (this._enableDiskRetryMode) {\n                        this._storeToDisk(envelopes);\n                    }\n                });\n\n                req.write(dataToSend);\n                req.end();\n            });\n        }\n    }\n\n    public saveOnCrash(envelopes: Contracts.EnvelopeTelemetry[]) {\n        if (this._enableDiskRetryMode) {\n            this._storeToDiskSync(Util.stringify(envelopes));\n        }\n    }\n\n    private _isRetriable(statusCode: number) {\n        return (\n            statusCode === 206 || // Partial Accept\n            statusCode === 401 || // Unauthorized\n            statusCode === 403 || // Forbidden\n            statusCode === 408 || // Timeout\n            statusCode === 429 || // Too many requests\n            statusCode === 500 || // Server Error\n            statusCode === 502 || // Bad Gateway\n            statusCode === 503 || // Server Unavailable\n            statusCode === 504 // Gateway Timeout\n        );\n    }\n\n    private _logInfo(message?: any, ...optionalParams: any[]) {\n        if (!this._isStatsbeatSender) {\n            Logging.info(Sender.TAG, message, optionalParams);\n        }\n    }\n\n    private _logWarn(message?: any, ...optionalParams: any[]) {\n        if (!this._isStatsbeatSender) {\n            Logging.warn(Sender.TAG, message, optionalParams);\n        }\n    }\n\n    private _statsbeatFailedToIngest() {\n        if (this._shutdownStatsbeat) { // Check if callback is available\n            this._failedToIngestCounter++;\n            if (this._failedToIngestCounter >= 3) {\n                this._shutdownStatsbeat();\n            }\n        }\n    }\n\n    /**\n     * Stores the payload as a json file on disk in the temp directory\n     */\n    private async _storeToDisk(envelopes: Contracts.EnvelopeTelemetry[]): Promise<void> {\n        try {\n            this._logInfo(\"Checking existence of data storage directory: \" + this._tempDir);\n            await FileSystemHelper.confirmDirExists(this._tempDir);\n        }\n        catch (ex) {\n            this._logWarn(\"Failed to create folder to put telemetry: \" + Util.dumpObj(ex));\n            this._onErrorHelper(ex);\n            return;\n        }\n        try {\n            await FileAccessControl.applyACLRules(this._tempDir);\n        }\n        catch (ex) {\n            this._logWarn(\"Failed to apply file access control to folder: \" + Util.dumpObj(ex));\n            this._onErrorHelper(ex);\n            return;\n        }\n        try {\n            let size = await FileSystemHelper.getShallowDirectorySize(this._tempDir);\n            if (size > this._maxBytesOnDisk) {\n                this._logWarn(\"Not saving data due to max size limit being met. Directory size in bytes is: \" + size);\n                return;\n            }\n        }\n        catch (ex) {\n            this._logWarn(\"Failed to read directory for retriable telemetry: \" + Util.dumpObj(ex));\n            this._onErrorHelper(ex);\n            return;\n        }\n        try {\n             //create file - file name for now is the timestamp, a better approach would be a UUID but that\n            //would require an external dependency\n            var fileName = new Date().getTime() + \".ai.json\";\n            var fileFullPath = path.join(this._tempDir, fileName);\n\n            // Mode 600 is w/r for creator and no read access for others (only applies on *nix)\n            // For Windows, ACL rules are applied to the entire directory (see logic in _confirmDirExists and _applyACLRules)\n            this._logInfo(\"saving data to disk at: \" + fileFullPath);\n            await FileSystemHelper.writeFileAsync(fileFullPath, Util.stringify(envelopes), { mode: 0o600 });\n        }\n        catch (ex) {\n            this._logWarn(\"Failed to persist telemetry to disk: \" + Util.dumpObj(ex));\n            this._onErrorHelper(ex);\n            return;\n        }\n    }\n\n    /**\n     * Stores the payload as a json file on disk using sync file operations\n     * this is used when storing data before crashes\n     */\n    private _storeToDiskSync(payload: any) {\n        try {\n            this._logInfo(\"Checking existence of data storage directory: \" + this._tempDir);\n            if (!fs.existsSync(this._tempDir)) {\n                fs.mkdirSync(this._tempDir);\n            }\n\n            // Make sure permissions are valid\n            FileAccessControl.applyACLRulesSync(this._tempDir);\n\n            let dirSize = FileSystemHelper.getShallowDirectorySizeSync(this._tempDir);\n            if (dirSize > this._maxBytesOnDisk) {\n                this._logInfo(\"Not saving data due to max size limit being met. Directory size in bytes is: \" + dirSize);\n                return;\n            }\n\n            //create file - file name for now is the timestamp, a better approach would be a UUID but that\n            //would require an external dependency\n            var fileName = new Date().getTime() + \".ai.json\";\n            var fileFullPath = path.join(this._tempDir, fileName);\n\n            // Mode 600 is w/r for creator and no access for anyone else (only applies on *nix)\n            this._logInfo(\"saving data before crash to disk at: \" + fileFullPath);\n            fs.writeFileSync(fileFullPath, payload, { mode: 0o600 });\n\n        } catch (error) {\n            this._logWarn(\"Error while saving data to disk: \" + Util.dumpObj(error));\n            this._onErrorHelper(error);\n        }\n    }\n\n    /**\n     * Check for temp telemetry files\n     * reads the first file if exist, deletes it and tries to send its load\n     */\n    private async _sendFirstFileOnDisk(): Promise<void> {\n        try {\n            let files = await FileSystemHelper.readdirAsync(this._tempDir);\n            files = files.filter(f => path.basename(f).indexOf(\".ai.json\") > -1);\n            if (files.length > 0) {\n                var firstFile = files[0];\n                var filePath = path.join(this._tempDir, firstFile);\n                let buffer = await FileSystemHelper.readFileAsync(filePath);\n                // delete the file first to prevent double sending\n                await FileSystemHelper.unlinkAsync(filePath);\n                let envelopes: Contracts.EnvelopeTelemetry[] = JSON.parse(buffer.toString());\n                await this.send(envelopes);\n            }\n        }\n        catch (err) {\n            this._onErrorHelper(err);\n        }\n    }\n\n    private _onErrorHelper(error: Error): void {\n        if (typeof this._onError === \"function\") {\n            this._onError(error);\n        }\n    }\n\n    private async _fileCleanupTask(): Promise<void> {\n        try {\n            let files = await FileSystemHelper.readdirAsync(this._tempDir);\n            files = files.filter(f => path.basename(f).indexOf(\".ai.json\") > -1);\n            if (files.length > 0) {\n                for (let i = 0; i < files.length; i++) {\n                    // Check expiration\n                    let fileCreationDate: Date = new Date(parseInt(files[i].split(\".ai.json\")[0]));\n                    let expired = new Date(+(new Date()) - Sender.FILE_RETEMPTION_PERIOD) > fileCreationDate;\n                    if (expired) {\n                        var filePath = path.join(this._tempDir, files[i]);\n                        await FileSystemHelper.unlinkAsync(filePath).catch((err) => {\n                            this._onErrorHelper(err);\n                        });\n                    }\n                }\n            }\n        }\n        catch (err) {\n            if (err.code != \"ENOENT\") {\n                this._onErrorHelper(err);\n            }\n        }\n    }\n}\n\nexport = Sender;"]}