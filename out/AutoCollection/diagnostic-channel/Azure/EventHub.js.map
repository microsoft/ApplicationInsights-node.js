{"version":3,"file":"EventHub.js","sourceRoot":"","sources":["../../../../AutoCollection/diagnostic-channel/Azure/EventHub.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,4DAA4D;AAC5D,oFAAoF;AACpF,0CAA8C;AAC9C,4CAA2D;AAC3D,4EAAyE;AAGzE,6DAOyC;AAGzC;;GAEG;AACH,IAAM,oBAAoB,GAAG,UAAC,IAAkB;IAC5C,IAAI,iBAAiB,GAAG,CAAC,CAAC;IAC1B,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,IAAM,WAAW,GAAG,2BAAoB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAEzD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAC,EAAc;YAAZ,UAAU,gBAAA;QAC5B,IAAM,YAAY,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,yBAAa,CAAoB,CAAC;QACpE,IAAI,YAAY,EAAE;YACd,iBAAiB,IAAI,CAAC,CAAC;YACvB,eAAe,IAAI,WAAW,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;SAC/E;IACL,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,CAAC,iBAAiB,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACnE,CAAC,CAAC;AAEF;;;;GAIG;AACI,IAAM,iBAAiB,GAAG,UAAC,IAAkB,EAAE,SAAgE;;IAClH,IAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,uBAAW,CAA6B,CAAC;IAC3E,IAAM,WAAW,GAAI,CAAC,IAAI,CAAC,UAAU,CAAC,yCAAkB,CAAC,aAAa,CAAC;QACnE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;QAC/B,SAAS,CAAY,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,sBAAsB;IACrE,IAAM,qBAAqB,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,iCAAqB,CAAC,IAAI,SAAS,CAAW,CAAC;IAE9F,QAAQ,IAAI,CAAC,IAAI,EAAE;QACf,KAAK,cAAQ,CAAC,MAAM;YACM,SAAU,CAAC,kBAAkB,GAAG,SAAS,CAAC;YAC1C,SAAU,CAAC,MAAM,GAAM,WAAW,SAAI,qBAAuB,CAAC;YACpF,MAAM;QACV,KAAK,cAAQ,CAAC,QAAQ;YACI,SAAU,CAAC,kBAAkB,GAAM,8BAAkB,CAAC,YAAY,WAAM,SAAW,CAAC;YACpF,SAAU,CAAC,MAAM,GAAM,WAAW,SAAI,qBAAuB,CAAC;YACpF,MAAM;QACV,KAAK,cAAQ,CAAC,QAAQ;YACC,SAAU,CAAC,MAAM,GAAM,WAAW,SAAI,qBAAuB,CAAC;YAC9D,SAAU,CAAC,YAAY,yBAChB,SAAU,CAAC,YAAY,gBAC5C,+BAAmB,IAAG,oBAAoB,CAAC,IAAI,CAAC,MACpD,CAAC;YACF,MAAM;QACV,QAAQ,CAAC,QAAQ;KACpB;AACL,CAAC,CAAC;AAzBW,QAAA,iBAAiB,qBAyB5B","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nimport { SpanKind } from \"@opentelemetry/api\";\nimport { hrTimeToMilliseconds } from \"@opentelemetry/core\";\nimport { SemanticAttributes } from \"@opentelemetry/semantic-conventions\";\nimport { ReadableSpan } from \"@opentelemetry/sdk-trace-base\";\n\nimport {\n    TIME_SINCE_ENQUEUED,\n    ENQUEUED_TIME,\n    AzNamespace,\n    MessageBusDestination,\n    MicrosoftEventHub,\n    DependencyTypeName\n} from \"../../../Declarations/Constants\";\nimport { DependencyTelemetry, Identified, RequestTelemetry } from \"../../../Declarations/Contracts\";\n\n/**\n * Average span.links[].attributes.enqueuedTime\n */\nconst getTimeSinceEnqueued = (span: ReadableSpan) => {\n    let countEnqueueDiffs = 0;\n    let sumEnqueueDiffs = 0;\n    const startTimeMs = hrTimeToMilliseconds(span.startTime);\n\n    span.links.forEach(({ attributes }) => {\n        const enqueuedTime = attributes?.[ENQUEUED_TIME] as string | number;\n        if (enqueuedTime) {\n            countEnqueueDiffs += 1;\n            sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);\n        }\n    });\n\n    return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);\n};\n\n/**\n * Implementation of Mapping to Azure Monitor\n *\n * https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#file-z_azure_monitor_exporter_mapping-md\n */\nexport const parseEventHubSpan = (span: ReadableSpan, telemetry: (DependencyTelemetry | RequestTelemetry) & Identified): void => {\n    const namespace = span.attributes[AzNamespace] as typeof MicrosoftEventHub;\n    const peerAddress = ((span.attributes[SemanticAttributes.NET_PEER_NAME] ||\n        span.attributes[\"peer.address\"] ||\n        \"unknown\") as string).replace(/\\/$/g, \"\"); // remove trailing \"/\"\n    const messageBusDestination = (span.attributes[MessageBusDestination] || \"unknown\") as string;\n\n    switch (span.kind) {\n        case SpanKind.CLIENT:\n            (<DependencyTelemetry>telemetry).dependencyTypeName = namespace;\n            (<DependencyTelemetry>telemetry).target = `${peerAddress}/${messageBusDestination}`;\n            break;\n        case SpanKind.PRODUCER:\n            (<DependencyTelemetry>telemetry).dependencyTypeName = `${DependencyTypeName.QueueMessage} | ${namespace}`;\n            (<DependencyTelemetry>telemetry).target = `${peerAddress}/${messageBusDestination}`;\n            break;\n        case SpanKind.CONSUMER:\n            (<RequestTelemetry>telemetry).source = `${peerAddress}/${messageBusDestination}`;\n            (<RequestTelemetry>telemetry).measurements = {\n                ...(<RequestTelemetry>telemetry).measurements,\n                [TIME_SINCE_ENQUEUED]: getTimeSinceEnqueued(span)\n            };\n            break;\n        default: // no op\n    }\n};"]}