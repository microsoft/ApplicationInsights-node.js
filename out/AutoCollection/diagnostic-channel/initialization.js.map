{"version":3,"file":"initialization.js","sourceRoot":"","sources":["../../../AutoCollection/diagnostic-channel/initialization.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,oFAAoF;;;AAOpF,+CAAkD;AAClD,uDAAsD;AAEzC,QAAA,aAAa,GAAG,CAAC,uBAAU,CAAC,WAAW,EAAE,CAAC,mBAAmB,CAAC;AAC3E,IAAM,GAAG,GAAG,mBAAmB,CAAC;AAEhC,IAAI,qBAAa,EAAE;IACf,IAAM,UAAU,GAAiC,OAAO,CAAC,+BAA+B,CAAC,CAAC;IAC1F,IAAM,iBAAiB,GAAW,uBAAU,CAAC,WAAW,EAAE,CAAC,cAAc,CAAC;IAC1E,IAAM,gBAAgB,GAAG,iBAAiB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACtD,IAAM,OAAO,GAA0B;QACnC,MAAM,EAAE,UAAU,CAAC,MAAM;QACzB,OAAO,EAAE,UAAU,CAAC,OAAO;QAC3B,OAAO,EAAE,UAAU,CAAC,OAAO;QAC3B,WAAW,EAAE,UAAU,CAAC,WAAW;QACnC,KAAK,EAAE,UAAU,CAAC,KAAK;QACvB,KAAK,EAAE,UAAU,CAAC,KAAK;QACvB,EAAE,EAAE,UAAU,CAAC,EAAE;QACjB,MAAM,EAAE,UAAU,CAAC,MAAM;QACzB,OAAO,EAAE,UAAU,CAAC,OAAO;QAC3B,QAAQ,EAAE,UAAU,CAAC,QAAQ;KAChC,CAAC;IACF,KAAK,IAAM,GAAG,IAAI,OAAO,EAAE;QACvB,IAAI,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;YACtC,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE,CAAC;YACtB,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,mBAAiB,GAAG,YAAS,CAAC,CAAC;SACpD;KACJ;IACD,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;QAC7B,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,kCAAkC,EAAE,gBAAgB,CAAC,CAAC;KAC3E;CACJ;KAAM;IACH,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,yGAAyG,CAAC,CAAC;CAChI;AAED,SAAgB,2BAA2B,CAAC,EAA8B;IACtE,IAAI,CAAC,qBAAa,EAAE;QAChB,OAAO;KACV;IACD,IAAM,WAAW,GAAI,OAAO,CAAC,oBAAoB,CAAwB,CAAC;IAC1E,WAAW,CAAC,OAAO,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;AACnD,CAAC;AAND,kEAMC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\n\r\n// Don't reference modules from these directly. Use only for types.\r\n// This is to avoid requiring the actual module if the NO_DIAGNOSTIC_CHANNEL env is present\r\nimport * as DiagChannelPublishers from \"diagnostic-channel-publishers\";\r\nimport * as DiagChannel from \"diagnostic-channel\";\r\nimport { AsyncScopeManager } from \"../AsyncHooksScopeManager\";\r\nimport Logging = require(\"../../Library/Logging\");\r\nimport { JsonConfig } from \"../../Library/JsonConfig\";\r\n\r\nexport const IsInitialized = !JsonConfig.getInstance().noDiagnosticChannel;\r\nconst TAG = \"DiagnosticChannel\";\r\n\r\nif (IsInitialized) {\r\n    const publishers: typeof DiagChannelPublishers = require(\"diagnostic-channel-publishers\");\r\n    const individualOptOuts: string = JsonConfig.getInstance().noPatchModules;\r\n    const unpatchedModules = individualOptOuts.split(\",\");\r\n    const modules: {[key: string] : any} = {\r\n        bunyan: publishers.bunyan,\r\n        console: publishers.console,\r\n        mongodb: publishers.mongodb,\r\n        mongodbCore: publishers.mongodbCore,\r\n        mysql: publishers.mysql,\r\n        redis: publishers.redis,\r\n        pg: publishers.pg,\r\n        pgPool: publishers.pgPool,\r\n        winston: publishers.winston,\r\n        azuresdk: publishers.azuresdk\r\n    };\r\n    for (const mod in modules) {\r\n        if (unpatchedModules.indexOf(mod) === -1) {\r\n            modules[mod].enable();\r\n            Logging.info(TAG, `Subscribed to ${mod} events`);\r\n        }\r\n    }\r\n    if (unpatchedModules.length > 0) {\r\n        Logging.info(TAG, \"Some modules will not be patched\", unpatchedModules);\r\n    }\r\n} else {\r\n    Logging.info(TAG, \"Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set\");\r\n}\r\n\r\nexport function registerContextPreservation(cb: (cb: Function) => Function) {\r\n    if (!IsInitialized) {\r\n        return;\r\n    }\r\n    const diagChannel = (require(\"diagnostic-channel\") as typeof DiagChannel);\r\n    diagChannel.channel.addContextPreservation(cb);\r\n}\r\n"]}