{"version":3,"file":"HttpRequests.js","sourceRoot":"","sources":["../../AutoCollection/HttpRequests.ts"],"names":[],"mappings":"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","sourcesContent":["import http = require(\"http\");\nimport https = require(\"https\");\n\nimport Contracts = require(\"../Declarations/Contracts\");\nimport TelemetryClient = require(\"../Library/TelemetryClient\");\nimport Logging = require(\"../Library/Logging\");\nimport Util = require(\"../Library/Util\");\nimport RequestResponseHeaders = require(\"../Library/RequestResponseHeaders\");\nimport HttpRequestParser = require(\"./HttpRequestParser\");\nimport { CorrelationContextManager, CorrelationContext, PrivateCustomProperties } from \"./CorrelationContextManager\";\nimport AutoCollectPerformance = require(\"./Performance\");\n\nclass AutoCollectHttpRequests {\n\n    public static INSTANCE: AutoCollectHttpRequests;\n    private static HANDLER_READY: boolean = false;\n\n    private static alreadyAutoCollectedFlag = \"_appInsightsAutoCollected\";\n\n    private _client: TelemetryClient;\n    private _isEnabled: boolean;\n    private _isInitialized: boolean;\n    private _isAutoCorrelating: boolean;\n\n    constructor(client: TelemetryClient) {\n        if (!!AutoCollectHttpRequests.INSTANCE) {\n            throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\n        }\n\n        AutoCollectHttpRequests.INSTANCE = this;\n        this._client = client;\n    }\n\n    public enable(isEnabled: boolean) {\n        this._isEnabled = isEnabled;\n\n        // Autocorrelation requires automatic monitoring of incoming server requests\n        // Disabling autocollection but enabling autocorrelation will still enable\n        // request monitoring but will not produce request events\n        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {\n            this.useAutoCorrelation(this._isAutoCorrelating);\n            this._initialize();\n        }\n    }\n\n    public useAutoCorrelation(isEnabled: boolean, forceClsHooked?: boolean) {\n        if (isEnabled && !this._isAutoCorrelating) {\n            CorrelationContextManager.enable(forceClsHooked);\n        } else if (!isEnabled && this._isAutoCorrelating) {\n            CorrelationContextManager.disable();\n        }\n        this._isAutoCorrelating = isEnabled;\n    }\n\n    public isInitialized() {\n        return this._isInitialized;\n    }\n\n    public isAutoCorrelating() {\n        return this._isAutoCorrelating;\n    }\n\n    private _generateCorrelationContext(requestParser: HttpRequestParser): CorrelationContext {\n        if (!this._isAutoCorrelating) {\n            return;\n        }\n\n        return CorrelationContextManager.generateContextObject(\n            requestParser.getOperationId(this._client.context.tags),\n            requestParser.getRequestId(),\n            requestParser.getOperationName(this._client.context.tags),\n            requestParser.getCorrelationContextHeader(),\n            requestParser.getTraceparent(),\n            requestParser.getTracestate()\n        );\n    }\n\n    private _registerRequest(request: http.ServerRequest, response: http.ServerResponse, onRequest: Function) {\n        // Set up correlation context\n        const requestParser = new HttpRequestParser(request);\n        const correlationContext = this._generateCorrelationContext(requestParser);\n\n        // Note: Check for if correlation is enabled happens within this method.\n        // If not enabled, function will directly call the callback.\n        CorrelationContextManager.runWithContext(correlationContext, () => {\n            if (this._isEnabled) {\n                // Mark as auto collected\n                (<any>request)[AutoCollectHttpRequests.alreadyAutoCollectedFlag] = true;\n\n                // Auto collect request\n                AutoCollectHttpRequests.trackRequest(this._client, { request: request, response: response }, requestParser);\n            }\n\n            if (typeof onRequest === \"function\") {\n                onRequest(request, response);\n            }\n        });\n    }\n\n    private _initialize() {\n        this._isInitialized = true;\n\n        // Avoid the creation of multiple handler on http(s).createServer\n        if (AutoCollectHttpRequests.HANDLER_READY) {\n            return;\n        }\n\n        AutoCollectHttpRequests.HANDLER_READY = true;\n\n        const wrapOnRequestHandler: Function = (onRequest?: Function) => {\n            if (!onRequest) {\n                return undefined;\n            }\n            if (typeof onRequest !== \"function\") {\n                throw new Error(\"onRequest handler must be a function\");\n            }\n            return (request: http.ServerRequest, response: http.ServerResponse) => {\n                CorrelationContextManager.wrapEmitter(request);\n                CorrelationContextManager.wrapEmitter(response);\n                const shouldCollect: boolean = request && !(<any>request)[AutoCollectHttpRequests.alreadyAutoCollectedFlag];\n\n                if (request && shouldCollect) {\n                    AutoCollectHttpRequests.INSTANCE?._registerRequest(request, response, onRequest)\n                } else {\n                    if (typeof onRequest === \"function\") {\n                        onRequest(request, response);\n                    }\n                }\n            }\n        };\n\n        // The `http.createServer` function will instantiate a new http.Server object.\n        // Inside the Server's constructor, it is using addListener to register the\n        // onRequest handler. So there are two ways to inject the wrapped onRequest handler:\n        // 1) Overwrite Server.prototype.addListener (and .on()) globally and not patching\n        //    the http.createServer call. Or\n        // 2) Overwrite the http.createServer method and add a patched addListener to the\n        //    fresh server instance. This seems more stable for possible future changes as\n        //    it also covers the case where the Server might not use addListener to manage\n        //    the callback internally.\n        //    And also as long as the constructor uses addListener to add the handle, it is\n        //    ok to patch the addListener after construction only. Because if we would patch\n        //    the prototype one and the createServer method, we would wrap the handler twice\n        //    in case of the constructor call.\n        const wrapServerEventHandler: Function = (server: (http.Server | https.Server)) => {\n            const originalAddListener = server.addListener.bind(server);\n            server.addListener = (eventType: string, eventHandler: Function) => {\n                switch (eventType) {\n                    case \"request\":\n                    case \"checkContinue\":\n                        return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));\n                    default:\n                        return originalAddListener(eventType, eventHandler);\n                }\n            };\n            // on is an alias to addListener only\n            server.on = server.addListener;\n        };\n\n        const originalHttpServer: any = http.createServer;\n\n        // options parameter was added in Node.js v9.6.0, v8.12.0\n        // function createServer(requestListener?: RequestListener): Server;\n        // function createServer(options: ServerOptions, requestListener?: RequestListener): Server;\n        http.createServer = (param1?: Object, param2?: Function) => {\n            // todo: get a pointer to the server so the IP address can be read from server.address\n            if (param2 && typeof param2 === \"function\") {\n                const server: http.Server = originalHttpServer(param1, wrapOnRequestHandler(param2));\n                wrapServerEventHandler(server);\n                return server;\n            }\n            else {\n                const server: http.Server = originalHttpServer(wrapOnRequestHandler(param1));\n                wrapServerEventHandler(server);\n                return server;\n            }\n        };\n\n        const originalHttpsServer = https.createServer;\n        https.createServer = (options: https.ServerOptions, onRequest?: Function) => {\n            const server: https.Server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));\n            wrapServerEventHandler(server);\n            return server;\n        };\n    }\n\n    /**\n     * Tracks a request synchronously (doesn't wait for response 'finish' event)\n     */\n    public static trackRequestSync(client: TelemetryClient, telemetry: Contracts.NodeHttpRequestTelemetry) {\n        if (!telemetry.request || !telemetry.response || !client) {\n            Logging.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\n            return;\n        }\n        telemetry.isProcessed = false;\n        AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\n\n        // store data about the request\n        var correlationContext = CorrelationContextManager.getCurrentContext();\n        var requestParser = new HttpRequestParser(telemetry.request, (correlationContext && correlationContext.operation.parentId));\n\n        // Overwrite correlation context with request parser results\n        if (correlationContext) {\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\n            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;\n            (<PrivateCustomProperties>correlationContext.customProperties).addHeaderData(requestParser.getCorrelationContextHeader());\n        }\n\n        AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);\n    }\n\n    /**\n     * Tracks a request by listening to the response 'finish' event\n     */\n    public static trackRequest(client: TelemetryClient, telemetry: Contracts.NodeHttpRequestTelemetry, _requestParser?: HttpRequestParser) {\n        if (!telemetry.request || !telemetry.response || !client) {\n            Logging.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !telemetry.request, !telemetry.response, !client);\n            return;\n        }\n        telemetry.isProcessed = false;\n        // store data about the request\n        var correlationContext = CorrelationContextManager.getCurrentContext();\n        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);\n\n        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {\n            AutoCollectHttpRequests.addResponseCorrelationIdHeader(client, telemetry.response);\n        }\n\n        // Overwrite correlation context with request parser results (if not an automatic track. we've already precalculated the correlation context in that case)\n        if (correlationContext && !_requestParser) {\n            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;\n            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;\n            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;\n            (<PrivateCustomProperties>correlationContext.customProperties).addHeaderData(requestParser.getCorrelationContextHeader());\n        }\n\n        // response listeners\n        if (telemetry.response.once) {\n            telemetry.response.once(\"finish\", () => {\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, null);\n            });\n        }\n\n        // track a failed request if an error is emitted\n        if (telemetry.request.on) {\n            telemetry.request.on(\"error\", (error: any) => {\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, error);\n            });\n        }\n\n        // track an aborted request if an aborted event is emitted\n        // Newer versions of Node.js runtime will trigger error event as well, we need to ensure telemetry is not generated multiple times\n        if (telemetry.request.on) {\n            telemetry.request.on(\"aborted\", () => {\n                const errorMessage = \"The request has been aborted and the network socket has closed.\";\n                AutoCollectHttpRequests.endRequest(client, requestParser, telemetry, null, errorMessage);\n            });\n        }\n    }\n\n    /**\n     * Add the target correlationId to the response headers, if not already provided.\n     */\n    private static addResponseCorrelationIdHeader(client: TelemetryClient, response: http.ServerResponse) {\n        if (client.config && client.config.correlationId &&\n            response.getHeader && response.setHeader && !(<any>response).headersSent) {\n            const correlationHeader = <any>response.getHeader(RequestResponseHeaders.requestContextHeader);\n            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);\n        }\n    }\n\n    private static endRequest(client: TelemetryClient, requestParser: HttpRequestParser, telemetry: Contracts.NodeHttpRequestTelemetry, ellapsedMilliseconds?: number, error?: any) {\n        if (telemetry.isProcessed) {\n            return;\n        }\n        telemetry.isProcessed = true;\n        if (error) {\n            requestParser.onError(error, ellapsedMilliseconds);\n        } else {\n            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);\n        }\n\n        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);\n\n        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);\n        if (telemetry.tagOverrides) {\n            for (let key in telemetry.tagOverrides) {\n                requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];\n            }\n        }\n\n        const legacyRootId = requestParser.getLegacyRootId();\n        if (legacyRootId) {\n            requestTelemetry.properties[\"ai_legacyRootId\"] = legacyRootId;\n        }\n\n        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};\n        requestTelemetry.contextObjects[\"http.ServerRequest\"] = telemetry.request;\n        requestTelemetry.contextObjects[\"http.ServerResponse\"] = telemetry.response;\n\n        client.trackRequest(requestTelemetry);\n    }\n\n    public dispose() {\n        AutoCollectHttpRequests.INSTANCE = null;\n        this.enable(false);\n        this._isInitialized = false;\n        CorrelationContextManager.disable();\n        this._isAutoCorrelating = false;\n    }\n}\n\nexport = AutoCollectHttpRequests;\n"]}