{"version":3,"file":"PreAggregatedMetrics.js","sourceRoot":"","sources":["../../AutoCollection/PreAggregatedMetrics.ts"],"names":[],"mappings":"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","sourcesContent":["import TelemetryClient = require(\"../Library/TelemetryClient\");\nimport Constants = require(\"../Declarations/Constants\");\n\nimport { AggregatedMetric } from \"../Declarations/Metrics/AggregatedMetric\";\nimport { AggregatedMetricCounter } from \"../Declarations/Metrics/AggregatedMetricCounters\";\nimport {\n    MetricBaseDimensions,\n    MetricDependencyDimensions,\n    MetricExceptionDimensions,\n    MetricRequestDimensions,\n    MetricTraceDimensions,\n    PreaggregatedMetricPropertyNames,\n    MetricDimensionTypeKeys\n} from \"../Declarations/Metrics/AggregatedMetricDimensions\";\nimport * as Contracts from \"../Declarations/Contracts\";\n\n\nclass AutoCollectPreAggregatedMetrics {\n\n    public static INSTANCE: AutoCollectPreAggregatedMetrics;\n    private _collectionInterval: number;\n    private _client: TelemetryClient;\n    private _handle: NodeJS.Timer;\n    private _isEnabled: boolean;\n    private _isInitialized: boolean;\n\n    private static _dependencyCountersCollection: Array<AggregatedMetricCounter>;\n    private static _requestCountersCollection: Array<AggregatedMetricCounter>;\n    private static _exceptionCountersCollection: Array<AggregatedMetricCounter>;\n    private static _traceCountersCollection: Array<AggregatedMetricCounter>;\n\n    /**\n     * @param client - Telemetry Client\n     * @param collectionInterval - Metric collection interval in ms\n     */\n    constructor(client: TelemetryClient, collectionInterval = 60000) {\n        if (!AutoCollectPreAggregatedMetrics.INSTANCE) {\n            AutoCollectPreAggregatedMetrics.INSTANCE = this;\n        }\n\n        this._isInitialized = false;\n        AutoCollectPreAggregatedMetrics._dependencyCountersCollection = [];\n        AutoCollectPreAggregatedMetrics._requestCountersCollection = [];\n        AutoCollectPreAggregatedMetrics._exceptionCountersCollection = [];\n        AutoCollectPreAggregatedMetrics._traceCountersCollection = [];\n        this._client = client;\n        this._collectionInterval = collectionInterval;\n    }\n\n    public enable(isEnabled: boolean, collectionInterval?: number) {\n        this._isEnabled = isEnabled;\n        if (this._isEnabled && !this._isInitialized) {\n            this._isInitialized = true;\n        }\n\n        if (isEnabled) {\n            if (!this._handle) {\n                this._collectionInterval = collectionInterval || this._collectionInterval;\n                this._handle = setInterval(() => this.trackPreAggregatedMetrics(), this._collectionInterval);\n                this._handle.unref(); // Allow the app to terminate even while this loop is going on\n            }\n        } else {\n            if (this._handle) {\n                clearInterval(this._handle);\n                this._handle = undefined;\n            }\n        }\n    }\n\n    public static countException(dimensions: MetricExceptionDimensions) {\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\n            return;\n        }\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._exceptionCountersCollection);\n        counter.totalCount++;\n    }\n\n    public static countTrace(dimensions: MetricTraceDimensions) {\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\n            return;\n        }\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._traceCountersCollection);\n        counter.totalCount++;\n    }\n\n    public static countRequest(duration: number | string, dimensions: MetricRequestDimensions) {\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\n            return;\n        }\n        let durationMs: number;\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._requestCountersCollection);\n        if (typeof duration === \"string\") {\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\n            durationMs = +new Date(\"1970-01-01T\" + duration + \"Z\"); // convert to num ms, returns NaN if wrong\n        } else if (typeof duration === \"number\") {\n            durationMs = duration;\n        } else {\n            return;\n        }\n        counter.intervalExecutionTime += durationMs;\n        counter.totalCount++;\n    }\n\n    public static countDependency(duration: number | string, dimensions: MetricDependencyDimensions) {\n        if (!AutoCollectPreAggregatedMetrics.isEnabled()) {\n            return;\n        }\n        let counter: AggregatedMetricCounter = AutoCollectPreAggregatedMetrics._getAggregatedCounter(dimensions, this._dependencyCountersCollection);\n        let durationMs: number;\n        if (typeof duration === \"string\") {\n            // dependency duration is passed in as \"00:00:00.123\" by autocollectors\n            durationMs = +new Date(\"1970-01-01T\" + duration + \"Z\"); // convert to num ms, returns NaN if wrong\n        } else if (typeof duration === \"number\") {\n            durationMs = duration;\n        } else {\n            return;\n        }\n        counter.intervalExecutionTime += durationMs;\n        counter.totalCount++;\n    }\n\n    public isInitialized() {\n        return this._isInitialized;\n    }\n\n    public static isEnabled() {\n        return AutoCollectPreAggregatedMetrics.INSTANCE && AutoCollectPreAggregatedMetrics.INSTANCE._isEnabled;\n    }\n\n    public trackPreAggregatedMetrics() {\n        this._trackRequestMetrics();\n        this._trackDependencyMetrics();\n        this._trackExceptionMetrics();\n        this._trackTraceMetrics();\n    }\n\n    private static _getAggregatedCounter(dimensions: MetricBaseDimensions, counterCollection: Array<AggregatedMetricCounter>): AggregatedMetricCounter {\n        let notMatch = false;\n        // Check if counter with specified dimensions is available\n        for (let i = 0; i < counterCollection.length; i++) {\n            // Same object\n            if (dimensions === counterCollection[i].dimensions) {\n                return counterCollection[i];\n            }\n            // Diferent number of keys skip\n            if (Object.keys(dimensions).length !== Object.keys(counterCollection[i].dimensions).length) {\n                continue;\n            }\n            // Check dimension values\n            for (let dim in dimensions) {\n                if ((<any>dimensions)[dim] != (<any>counterCollection[i].dimensions)[dim]) {\n                    notMatch = true;\n                    break;\n                }\n            }\n            if (!notMatch) { // Found\n                return counterCollection[i];\n            }\n            notMatch = false;\n        }\n        // Create a new one if not found\n        let newCounter = new AggregatedMetricCounter(dimensions);\n        counterCollection.push(newCounter);\n        return newCounter;\n    }\n\n    private _trackRequestMetrics() {\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._requestCountersCollection.length; i++) {\n            var currentCounter = AutoCollectPreAggregatedMetrics._requestCountersCollection[i];\n            currentCounter.time = +new Date;\n            var intervalRequests = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\n            var averageRequestExecutionTime = ((currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalRequests) || 0;\n            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime; // reset\n            if (elapsedMs > 0 && intervalRequests > 0) {\n                this._trackPreAggregatedMetric({\n                    name: \"Server response time\",\n                    dimensions: currentCounter.dimensions,\n                    value: averageRequestExecutionTime,\n                    count: intervalRequests,\n                    aggregationInterval: elapsedMs,\n                    metricType: Constants.MetricId.REQUESTS_DURATION\n                });\n            }\n            // Set last counters\n            currentCounter.lastTotalCount = currentCounter.totalCount;\n            currentCounter.lastTime = currentCounter.time;\n        }\n    }\n\n    private _trackDependencyMetrics() {\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._dependencyCountersCollection.length; i++) {\n            var currentCounter = AutoCollectPreAggregatedMetrics._dependencyCountersCollection[i];\n            currentCounter.time = +new Date;\n            var intervalDependencies = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\n            var averageDependencyExecutionTime = ((currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalDependencies) || 0;\n            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime; // reset\n            if (elapsedMs > 0 && intervalDependencies > 0) {\n                this._trackPreAggregatedMetric({\n                    name: \"Dependency duration\",\n                    dimensions: currentCounter.dimensions,\n                    value: averageDependencyExecutionTime,\n                    count: intervalDependencies,\n                    aggregationInterval: elapsedMs,\n                    metricType: Constants.MetricId.DEPENDENCIES_DURATION\n                });\n            }\n            // Set last counters\n            currentCounter.lastTotalCount = currentCounter.totalCount;\n            currentCounter.lastTime = currentCounter.time;\n        }\n    }\n\n    private _trackExceptionMetrics() {\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._exceptionCountersCollection.length; i++) {\n            var currentCounter = AutoCollectPreAggregatedMetrics._exceptionCountersCollection[i];\n            currentCounter.time = +new Date;\n            var intervalExceptions = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\n            if (elapsedMs > 0 && intervalExceptions > 0) {\n                this._trackPreAggregatedMetric({\n                    name: \"Exceptions\",\n                    dimensions: currentCounter.dimensions,\n                    value: intervalExceptions,\n                    count: intervalExceptions,\n                    aggregationInterval: elapsedMs,\n                    metricType: Constants.MetricId.EXCEPTIONS_COUNT\n                });\n            }\n            // Set last counters\n            currentCounter.lastTotalCount = currentCounter.totalCount;\n            currentCounter.lastTime = currentCounter.time;\n        }\n    }\n\n    private _trackTraceMetrics() {\n        for (let i = 0; i < AutoCollectPreAggregatedMetrics._traceCountersCollection.length; i++) {\n            var currentCounter = AutoCollectPreAggregatedMetrics._traceCountersCollection[i];\n            currentCounter.time = +new Date;\n            var intervalTraces = (currentCounter.totalCount - currentCounter.lastTotalCount) || 0;\n            var elapsedMs = currentCounter.time - currentCounter.lastTime;\n            if (elapsedMs > 0 && intervalTraces > 0) {\n                this._trackPreAggregatedMetric({\n                    name: \"Traces\",\n                    dimensions: currentCounter.dimensions,\n                    value: intervalTraces,\n                    count: intervalTraces,\n                    aggregationInterval: elapsedMs,\n                    metricType: Constants.MetricId.TRACES_COUNT\n                });\n            }\n            // Set last counters\n            currentCounter.lastTotalCount = currentCounter.totalCount;\n            currentCounter.lastTime = currentCounter.time;\n        }\n    }\n\n    private _trackPreAggregatedMetric(metric: AggregatedMetric) {\n        // Build metric properties\n        let metricProperties: any = {};\n        for (let dim in metric.dimensions) {\n            metricProperties[PreaggregatedMetricPropertyNames[dim as MetricDimensionTypeKeys]] = metric.dimensions[dim];\n        }\n        metricProperties = {\n            ...metricProperties,\n            \"_MS.MetricId\": metric.metricType,\n            \"_MS.AggregationIntervalMs\": String(metric.aggregationInterval),\n            \"_MS.IsAutocollected\": \"True\"\n        };\n\n        let telemetry: Contracts.MetricTelemetry = {\n            name: metric.name,\n            value: metric.value,\n            count: metric.count,\n            properties: metricProperties,\n            kind: \"Aggregation\"\n        };\n        this._client.trackMetric(telemetry);\n    }\n\n    public dispose() {\n        AutoCollectPreAggregatedMetrics.INSTANCE = null;\n        this.enable(false);\n        this._isInitialized = false;\n    }\n}\n\nexport = AutoCollectPreAggregatedMetrics;\n"]}